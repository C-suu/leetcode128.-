# leetcode128. 最长连续序列

# 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请设计并实现时间复杂度为 O(n) 的算法解决此问题。

```python
示例 1：
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

示例 2：
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9

示例 3：
输入：nums = [1,0,1,2]
输出：3
```

下面这题（力扣 128：最长连续序列）想要 **O(n)**，核心技巧是：**用哈希集合 set 做“查找是否存在”**，并且只从“连续序列的起点”开始数。

---

## ✅ 直接答案（Python）

```python
from typing import List

class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        s = set(nums)          # 把所有数字放进集合，方便 O(1) 查询
        best = 0               # 记录目前找到的最长长度

        for x in s:            # 遍历集合里的每个数字（去重后）
            if x - 1 not in s: # 只有当 x 是“某段连续序列的起点”才开始数
                y = x
                while y in s:  # 一直往后找 x, x+1, x+2...
                    y += 1
                best = max(best, y - x)  # y 走到第一个不在集合的位置，长度是 y-x

        return best
```

---

## 🧠 用最白话解释这段代码在干嘛

### 1）为什么用 `set(nums)`？

* `set`（集合）有个超强能力：**问“某个数在不在里面”很快**
  比如 `7 in s` 通常是 **O(1)**（近似常数时间）。
* 而如果用 list（列表）去找，`7 in nums` 可能要从头扫到尾，慢很多。

### 2）为什么要“只从起点开始数”？

如果对每个数都往后数，会重复做很多工作。

比如 `[1,2,3,4]`

* 从 1 数：1→2→3→4（很好）
* 从 2 数：2→3→4（重复）
* 从 3 数：3→4（重复）

所以我们规定：
**只有当 `x-1` 不存在时，x 才是起点**
例如：

* `1-1=0` 不在集合里 → 1 是起点 ✅
* `2-1=1` 在集合里 → 2 不是起点 ❌（跳过）

这样每个数字最多被 while 扫到一次，总体 O(n)。

---

## 🔤 逐字逐句解释（把“字母/符号”都讲清楚）

我会按行讲，每行里出现的英文/符号都解释。

---

### ✅ 第 1 行

`from typing import List`

* `from`：从某个地方拿东西
* `typing`：Python 的“类型提示”工具包名字
* `import`：导入
* `List`：表示“列表类型”（比如 `List[int]` 表示“整数列表”）

> 这行不是必须的，只是让代码更规范好读。

---

### ✅ 第 2 行

`class Solution:`

* `class`：定义一个“类”（LeetCode 固定写法）
* `Solution`：类名，必须叫 Solution（平台约定）
* `:`（冒号）：告诉 Python “下面是这个类的内容”，后面要缩进

---

### ✅ 第 3 行

`def longestConsecutive(self, nums: List[int]) -> int:`

逐个解释：

* `def`：定义函数
* `longestConsecutive`：函数名（最长连续序列）
* `(` `)`：括号，里面放参数
* `self`：类里的函数都会带的东西（先当成固定写法即可）
* `,`：逗号，分隔参数
* `nums`：参数名，表示输入数组
* `:`（冒号）出现在 `nums:` 后面：表示“nums 的类型是……”
* `List[int]`：nums 是一个“整数列表”

  * `List`：列表
  * `[ ]`：里面写元素类型
  * `int`：整数（integer）
* `-> int`：表示“这个函数返回一个 int（整数）”
* 最后的 `:`：函数体开始，下面要缩进

---

### ✅ 第 4 行

`s = set(nums)`

* `s`：变量名（可以理解为“集合 set”）
* `=`：把右边的结果存到左边变量
* `set(...)`：把括号里的东西变成集合
* `nums`：输入列表

集合的特点：

* 自动去重（重复的元素只保留一个）
* 查找快：`x in s`

---

### ✅ 第 5 行

`best = 0`

* `best`：记录“目前最长长度”
* `=`：赋值
* `0`：初始值（还没找到任何连续序列时，最长是 0）

---

### ✅ 第 6 行

`for x in s:`

* `for`：循环
* `x`：循环变量，每次拿一个元素出来
* `in`：在……里面
* `s`：集合
* `:`：循环体开始

意思：**把集合 s 里的每个数字都拿出来看看**

---

### ✅ 第 7 行

`if x - 1 not in s:`

逐个拆：

* `if`：如果
* `x - 1`：x 减 1（看 x 的前一个数）
* `not in`：不在……里面
* `s`：集合
* `:`：if 条件成立就执行下面缩进内容

意思：
**如果 x 的前一个数不存在，那么 x 就是某段连续序列的起点**

---

### ✅ 第 8 行

`y = x`

* `y`：另一个变量，用来往后走
* `=`：赋值
* `x`：从起点开始

---

### ✅ 第 9 行

`while y in s:`

* `while`：当……时一直循环
* `y in s`：y 是否存在于集合 s
* `:`：循环体开始

意思：
**只要 y 还在集合里，就继续往后**

---

### ✅ 第 10 行

`y += 1`

* `+=`：一种简写
* `y += 1` 等价于 `y = y + 1`
* `1`：每次往后走一步

意思：
y 从 x 走到 x+1、x+2、x+3……直到不在集合为止

---

### ✅ 第 11 行

`best = max(best, y - x)`

逐个解释：

* `best = ...`：更新 best
* `max(a, b)`：取 a 和 b 中较大的那个
* `y - x`：长度

  * 注意：当 while 结束时，y 已经走到“第一个不在集合的数”
  * 如果序列是 1,2,3,4，那么 y 会变成 5
    所以长度 = 5 - 1 = 4

---

### ✅ 第 13 行

`return best`

* `return`：返回结果
* `best`：最长连续序列的长度

---

## ✅ 用示例 1 跑一遍会更懂

nums = [100,4,200,1,3,2]
集合 s = {1,2,3,4,100,200}

遍历时：

* x=1：1-1=0 不在 s → 起点
  y=1 →2→3→4→5(不在)
  best=max(0,5-1)=4
* x=2：2-1=1 在 s → 不是起点，跳过
* x=3：跳过
* x=4：跳过
* 其他数字也只能形成长度 1
  最终 best=4

---

行，我把 **示例 1、2、3** 全部一次性做成“调试日志表格”：
每个示例都给两张表：

1. 外层 `for x in s` 的表（看哪些 x 会进入 while）
2. 进入 while 的“逐步 y 变化表”（真正数长度的过程）

> 说明：Python 的 `set` 遍历顺序不固定。为了更好理解，我在表格里都按从小到大排列。**不影响最终答案**。

---

# 示例 1

输入：`nums = [100,4,200,1,3,2]`
去重集合：`s = {1,2,3,4,100,200}`

## 表格 1-1：外层 for

|   x | x-1 | `x-1 in s`? | x 是起点吗? | 会进入 while 吗 | 数出来的长度 | best 更新后 |
| --: | --: | :---------: | :-----: | :---------: | -----: | -------: |
|   1 |   0 |      否      |    ✅    |      ✅      |      4 |        4 |
|   2 |   1 |      是      |    ❌    |      ❌      |      — |        4 |
|   3 |   2 |      是      |    ❌    |      ❌      |      — |        4 |
|   4 |   3 |      是      |    ❌    |      ❌      |      — |        4 |
| 100 |  99 |      否      |    ✅    |      ✅      |      1 |        4 |
| 200 | 199 |      否      |    ✅    |      ✅      |      1 |        4 |

> 这里会进入 while 的起点是：1、100、200。

---

## 表格 1-2：while（x=1 时）

| while 轮次 | 当前 y | `y in s`? | 执行 `y += 1` 后 y |
| -------: | ---: | :-------: | --------------: |
|        1 |    1 |     是     |               2 |
|        2 |    2 |     是     |               3 |
|        3 |    3 |     是     |               4 |
|        4 |    4 |     是     |               5 |
|        5 |    5 |     否     |              停止 |

长度 = `y - x = 5 - 1 = 4`

---

## 表格 1-3：while（x=100 时）

| while 轮次 | 当前 y | `y in s`? | 执行 `y += 1` 后 y |
| -------: | ---: | :-------: | --------------: |
|        1 |  100 |     是     |             101 |
|        2 |  101 |     否     |              停止 |

长度 = `101 - 100 = 1`

---

## 表格 1-4：while（x=200 时）

| while 轮次 | 当前 y | `y in s`? | 执行 `y += 1` 后 y |
| -------: | ---: | :-------: | --------------: |
|        1 |  200 |     是     |             201 |
|        2 |  201 |     否     |              停止 |

长度 = `201 - 200 = 1`

✅ 最终输出：`4`

---

# 示例 2

输入：`nums = [0,3,7,2,5,8,4,6,0,1]`
去重集合：`s = {0,1,2,3,4,5,6,7,8}`

## 表格 2-1：外层 for

|  x | x-1 | `x-1 in s`? | x 是起点吗? | 会进入 while 吗 | 数出来的长度 | best 更新后 |
| -: | --: | :---------: | :-----: | :---------: | -----: | -------: |
|  0 |  -1 |      否      |    ✅    |      ✅      |      9 |        9 |
|  1 |   0 |      是      |    ❌    |      ❌      |      — |        9 |
|  2 |   1 |      是      |    ❌    |      ❌      |      — |        9 |
|  3 |   2 |      是      |    ❌    |      ❌      |      — |        9 |
|  4 |   3 |      是      |    ❌    |      ❌      |      — |        9 |
|  5 |   4 |      是      |    ❌    |      ❌      |      — |        9 |
|  6 |   5 |      是      |    ❌    |      ❌      |      — |        9 |
|  7 |   6 |      是      |    ❌    |      ❌      |      — |        9 |
|  8 |   7 |      是      |    ❌    |      ❌      |      — |        9 |

> 只有起点 `x=0` 会进入 while，一次数完就是最长 9。

---

## 表格 2-2：while（x=0 时）

| while 轮次 | 当前 y | `y in s`? | 执行 `y += 1` 后 y |
| -------: | ---: | :-------: | --------------: |
|        1 |    0 |     是     |               1 |
|        2 |    1 |     是     |               2 |
|        3 |    2 |     是     |               3 |
|        4 |    3 |     是     |               4 |
|        5 |    4 |     是     |               5 |
|        6 |    5 |     是     |               6 |
|        7 |    6 |     是     |               7 |
|        8 |    7 |     是     |               8 |
|        9 |    8 |     是     |               9 |
|       10 |    9 |     否     |              停止 |

长度 = `9 - 0 = 9`

✅ 最终输出：`9`

---

# 示例 3

输入：`nums = [1,0,1,2]`
去重集合：`s = {0,1,2}`

## 表格 3-1：外层 for

|  x | x-1 | `x-1 in s`? | x 是起点吗? | 会进入 while 吗 | 数出来的长度 | best 更新后 |
| -: | --: | :---------: | :-----: | :---------: | -----: | -------: |
|  0 |  -1 |      否      |    ✅    |      ✅      |      3 |        3 |
|  1 |   0 |      是      |    ❌    |      ❌      |      — |        3 |
|  2 |   1 |      是      |    ❌    |      ❌      |      — |        3 |

---

## 表格 3-2：while（x=0 时）

| while 轮次 | 当前 y | `y in s`? | 执行 `y += 1` 后 y |
| -------: | ---: | :-------: | --------------: |
|        1 |    0 |     是     |               1 |
|        2 |    1 |     是     |               2 |
|        3 |    2 |     是     |               3 |
|        4 |    3 |     否     |              停止 |

长度 = `3 - 0 = 3`

✅ 最终输出：`3`

---

